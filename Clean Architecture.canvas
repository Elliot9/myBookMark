{
	"nodes":[
		{"id":"cc8605240e2c734a","type":"text","text":"## 第一章：什麼是設計與結構\n### 軟體架構的目標是最小化建置和維護『需求系統』所需要的人力資源\n\n軟體設計品質的度量標準，在於滿足客戶需求所花的精力\n\n如果所需的精力是少的，且在系統的生命週期中也都保持是少的，那麼設計就是好的  \n如果所需的精力會隨著版本更新而增長的話，則這個設計就是不好的","x":-1600,"y":-1380,"width":740,"height":220},
		{"id":"bd1646d32d33209f","type":"text","text":"## 第三章 ： 範式概論\n## 範式（paradigm）是什麼？\n\n- 範式是程式設計的方式，和語言無關。\n- 範式可告知何時使用哪種設計架構。\n- 範式共三種：結構化程式設計（structured programming）、物件導向程式設計（object-orient programming）、函數式程式設計（functional programming）。\n\n\n## 結構化程式設計\n\n- 結構化程式設計在 ==直接== 的控制權轉移上加上規範。\n- 由於無限制的跳耀（goto）是有害的，因此在結構化程式設計中，取而代之的是 `if/then/else` 和 `do/while/until`。\n    - 這是因為 goto 的某些使用情境會導致模組無法切小，進而無法使用分而治之（divide-and-conquer）來分解程式碼為更小的單元；而扣除掉這些不好的情境，使用 goto 的控制邏輯可對應到 `if/then/else` 和 `do/while` 。\n- 結構化程式設計是模組的基礎。\n\n## 物件導向程式設計\n\n- 物件導向程式設計在 ==間接== 的控制權轉移上加上規範。\n- 擁有類別（class）、建構子（constructor）、實例變數（instance variable）、方法（method）、多型（polymorphism）。\n- 「多型」是跨越架構邊界的機制。\n\n## 函數式程式設計\n\n- 函數式程式設計在賦值上加上規範。\n- 核心概念是不變性（immutability），因此函數式語言沒有賦值語句（assignment statement），或必須在嚴格的規範下進行。\n- 「不變性」規範資料的位置和存取的機制。\n\n\n\n\n###  結構化程式設計移除「goto」。\n###  物件導向程式設計移除「==函式指標==」。\n### 函數式程式設計移除「賦值」。","x":-1600,"y":-240,"width":940,"height":1006},
		{"id":"07127ef8f304e0e7","type":"text","text":"## 第四章：結構化程式設計\n## goto 的沒落\n\n- goto 的某些使用情境會導致模組無法切小，進而無法使用分而治之（divide-and-conquer）來分解程式碼為更小的單元；而扣除掉這些不好的情境，使用 goto 的控制邏輯可對應到 `if/then/else` 和 `do/while`。\n- 結構化程式的建立是指所有的程式都可以使用三種結構建立出來：==循序（sequence）、選擇（selection）、迭代（iteration）==。\n- 結構化程式可將模組遞迴地分解為更小的單元，也就是可用循序、選擇、迭代這三種控制結構來無限分解為更小的模組、元件或更低一級的功能。在接下來的測試中，即可用這些小功能來做測試。\n\n## 測試\n\n- 結構化的程式可經由足夠多的測試來證明它是正確的。\n    - 測試顯示了錯誤的存在，而不是沒有錯誤。\n    - 測試可以證明程式是不正確的，但沒有辦法證明是正確的。(只能透過無法證明其非正確性)\n    - 經過足夠的測試後，這些測試讓我們相信程式是足夠正確的。\n    - 將程式切小後，用小部份來分別做測試。\n- 證明不正確的這個方法，僅限於「被證明的東西」是「可以被證明的」；一個不能被證明的程式（例如：無限制使用 goto 的程式）就無法用「證明不正確」這個方法來證明它是足夠正確的。","x":-520,"y":-1393,"width":1609,"height":467},
		{"id":"3b8b7529cc723ab4","type":"text","text":"## 第五章：物件導向程式設計\n\n## 什麼是「物件導向」？\n\n- （X）答案一：資料與函式（功能）的結合。\n- （X）答案二：一種模擬真實世界的方式。\n- （O）答案三：封裝 + 繼承 + 多型。\n\n---\n\n物件導向的程式語言必須至少包含以下三件事\n- 封裝（encapsulation）\n- 繼承（inheritance）\n- 多型（polymorphism）\n\n\n### 封裝\n\n一組具有緊密關聯的資料和函式繪製出一個框  \n對於框外而言，資料是隱藏的，只有一些函式是已知的\n\n現在聲稱提供 OO 的語言  \n例如 Java 和 C#，廢除了標頭／實作的拆分，弱化了封裝  \n這些語言無法將一個類別的宣告（declaration）和定義（definition）做分離\n\n相對於過去 C 語言裡就享有的完美封裝  \n我們很難接受 OO 是依賴於強封裝之上  \n事實上，許多物件導向語言很少或根本沒有==強制性封裝==\n\n\n### 繼承\n\n在 C 語言裡早已有能做到繼承的方法  \n不過這個技巧並不好用，且若想實現多重繼承是困難的\n\n所以在 OO 語言發明以前就已經有繼承的方法，只是並不方便  \n雖然繼承不是 OO 語言帶來的，但確實使繼承變得更容易\n\n### 多型\n\n在 OO 語言之前，就已存在多型的行為  \n以 C 語言來說，過去的程式設計師以函式指標來實現多型\n\n但這樣的使用方式十分危險，得基於一系列手動約定才得以達成  \n只要有任何程式設計師沒有遵照這些約定，就會產生難以追查和消除的 bug\n\n但 OO 語言消除了這些約定，進而排除這些危險  \nOO 語言雖沒有帶來多型，但讓多型更安全和方便\n\n依賴反向便是多型的一個應用\n\n==OO 在間接的控制移轉上加上了規範==\n\n\n## 依賴反向\n\n呼叫樹（calling tree）經由流程控制而呼叫一個又一個的函式，而呼叫函式時必須呼叫它的名字（module name），這樣函式與函式間的相依程度是很高的。\n\n解法是使用一個介面（interface）來達成「依賴反向」。這樣做的優點是能將「業務邏輯」與「程式邏輯」切分，也就是說，UI 與 DB 可以當成業務邏輯的 plugin，當 UI 與 DB 有變更時可以獨立部署而不影響業務邏輯。","x":-520,"y":-860,"width":710,"height":1480},
		{"id":"b177a35d5826d0a1","type":"text","text":"## 第六章：函數式程式架構\n\n### 不可變與架構\n\n變數是不會被改變的\n為什麼架構師會關心變數的可變性？  \n因為所有競爭條件（race condition）、deadlock 和平行更新問題（concurrent update problem）都來自於可變的變數  \n如果沒有變數會被更新，就不會有以上的問題\n\n### 可變性的分離\n1. **可變性分離：** 區分應用程式或服務中的可變和不可變元件。\n2. **不可變元件：** 以純函數式的方式執行任務，不使用可變變數。\n3. **交易式記憶體：** 作為一種保護可變變數的解決方案，類似於將記憶體視作資料庫，並使用交易或重試方式保護變數。\n4. **Clojure 的 `atom`：** 是一種特殊變數，允許在嚴格條件下的可變性，並通過 `swap!` 函式來執行可變操作。\n\n\n\n### 事件來源（Event Sourcing）\n\n設想一個維護客戶帳戶餘額的應用程式，當進行存款或取款時就會改變餘額  \n==想像一下，如果不是儲存帳戶餘額，而是儲存交易==  \n每當查詢餘額時，只需將帳戶從開始時的所有交易加總起來，這個方案就不需要可變的變數\n\n### 總結\n\n• 結構化程式設計就是在直接控制移轉上加上規範。\n• 物件導向程式設計就是在間接控制移轉上加上規範。\n• 函數式程式設計就是在變數賦值上加上規範。\n這三種範式的每一種，都從我們身上奪走了一些東西。每個範式都限制了我們寫程式的方式。他們都沒有增強我們的力量或增加我們的能力。\n\n我們在過去半個世紀裡所學到的，是哪些是不該做的（what not to do）\n工具是產生了變化，硬體是產生了變化，但軟體的本質是相同的。\n軟體就是由循序、選擇、迭代循環（iteration）和 ==間接（indirection）==所組成的電腦程式內容，如此而已。沒有更多，也沒有更少\n","x":-520,"y":680,"width":1020,"height":900},
		{"id":"a59066e4d46b8268","type":"text","text":"## 第二章：兩種價值觀\n\n軟體的核心價值在於它所實現的功能、其行為以及對問題的解決能力，而不僅僅是程式碼的撰寫或技術堆疊的選擇。\n\n在進行軟體設計時，強調著重於定義和捕捉軟體的行為。這意味著設計者應該優先考慮的是軟體的功能、使用者需求和期望的**行為**，而不是特定的技術細節或程式碼實現的方式。 ^88d128\n\n\n好的軟體，進行改變的難度應該只與改變的範圍成正比，而不是改變的形狀成正比\n\n對於不斷演進的需求，對開發者來說就像是在玩拼圖遊戲，他們必須適應不斷增加的複雜性，每個新的請求都比上一個更難達到，**因為系統的形狀與請求的形狀無法對應起來**\n\n**軟體開發人員常常覺得自己被迫將『方釘』塞入『圓孔』**\n### 更高的價值\n\n『行為』和『架構』哪個比較重要？  \n軟體系統能夠工作比較重要，還是軟體系統更容易變更比較重要？  \n觀察以下兩個例子：\n\n- 有一個完美滿足需求的程式，但是不可能修改  \n    那麼當需求改變時，它就不能工作了，而工程師也無法使其工作  \n    **所以這個程式將變得毫無用處**\n- 有一個程式沒有正確運作，但是易於修改  \n    那麼工程師可以修改使其可以工作，並隨著需求的變化而繼續工作  \n    **因此，該程式將持續是有用的**\n\n雖然沒有一個程式是不可改變的，但是有些系統實際上不可能改變，**因為改變的成本超過了改變的利益**\n\n**軟體開發人員的一個困境是業務經理沒有能力去評估架構的重要性，而這就是軟體開發人員該去做的**  \n軟體開發團隊有責任主張架構的重要性高於功能的迫切性\n\n\n\n","x":-1600,"y":-1080,"width":940,"height":760},
		{"id":"531018b62c8b2b62","type":"text","text":"1. 作者提到\"決策的目標是最小化建置和維護系統所需要的人力\"。說說你在面對不同做法或寫法的決擇時，會影響你做決策的點有哪些？\n\n    a: 作者有提到應該把事情做對，才能達到最小化建置和維護系統所需的人力，我覺得怎樣叫 ==做把事情做對== 很抽象，所以我比較常使用 ==不喜歡== 哪種作法和寫法去依據。 那對我來說，我不喜歡可讀性差，不利於擴展的，或是對於可預期變化的地方沒有多做保護的設計。\n\n2. 作者提到\"開發團隊必須為他們認為對公司是最好的事情而爭鬥，開發團隊有責任主張架構的重要性高於功能的迫切性\"。說說你在判斷一個需求是否能執行時，你的底限是什麼？\n\n\ta: 我通常會依據現有的資料結構或類別去思考需求的可行性，當需求一定程度的破壞了原本封裝，也就是背離了原先的設計時，我通常會反問，需求是否合理正確？  舉例： 我想要讓蛋糕學會游泳？ 這個需求就顯然超出了蛋糕的本質和設計。這樣的需求與蛋糕的特性和預期功能完全不符合。\n\n3. 在讀完本書第一部份後，舉 1 ~ 3 項讓你最有印象的\"新\"觀點 (每個人回答)\n\n\ta: 開發人員可能會認為答案是從頭開始重新設計整個系統—但這只不過是免子再次發言 ， 但我覺得這句話 意義在於提醒開發人員，即使在面臨困難時，也不應該輕率地選擇全面重構或重新設計整個系統。這並非解決問題的唯一方法，而且可能產生更多的問題。相反，更有效的方法可能是分析問題的根源，有針對性地進行局部改進或重構，以確保系統的穩定性和持續性，同時在必要時進行整體性的改變。\n\n\n\ta: 軟體第一個價值：行為 - 完成商業需求，是迫切的但並不總是特別重要\n\t   軟體第二個價值：結構 - 適應不斷增加的複雜性，是重要的但從不特別迫切\n\t\t所以優先程度是 二 高於 一 ，但我感覺現實往往是一大於二\n\n","x":-2960,"y":-1080,"width":900,"height":660},
		{"id":"c6d3ea1b04c2e831","type":"text","text":"函式指標，是一個指標，指向某「特定函式型別」，函式型別由其「返回型別和參數列」決定\n\n例如\n````\n#include <stdio.h> void sayHello() { printf(\"Hello, world!\\n\"); } void sayGoodbye() { printf(\"Goodbye, world!\\n\"); } int main() { void (*functionPointer)(); // 函式指標的宣告 functionPointer = sayHello; functionPointer(); // 調用 sayHello 函式 functionPointer = sayGoodbye; functionPointer(); // 調用 sayGoodbye 函式 return 0; }\n````\n\n\n 物件導向程式設計強調 **封裝**，它允許你將數據和相關操作封裝在一個對象內。相應的行為通常作為該對象的方法存在。這種方式下，你不需要直接操作函式指標來調用函式，而是透過對象的方法\n \n ","x":-2120,"y":506,"width":410,"height":554,"color":"4"},
		{"id":"7afc2066799129de","type":"text","text":"直接可以在程式碼上看到控制","x":-2040,"y":100,"width":300,"height":60,"color":"4"},
		{"id":"b8c5ca81fcdfea54","type":"text","text":"物件之間的互動，物件彼此之間通過消息傳遞來觸發方法的調用，從而間接地控制程式的執行流程 \n\n","x":-2050,"y":263,"width":340,"height":120,"color":"4"},
		{"id":"94faa61e87a84cea","type":"text","text":"1. **循序（Sequence）：** 循序結構代表程式碼的順序執行，即按照順序逐步執行每一條程式語句。程式碼從頭到尾按照指定的順序執行，每條指令都在前一條指令完成後執行。這是最基本的程式控制流結構。\n    \n2. **選擇（Selection）：** 選擇結構允許根據條件執行不同的程式碼路徑。這通常使用條件語句，比如 if、else if 和 else，來根據條件的真偽來決定程式碼的執行路徑。例如，根據不同的條件選擇不同的程式碼塊來執行。\n    \n3. **迭代（Iteration）：** 迭代結構允許重複執行程式碼塊，直到滿足特定條件後才停止。這通常使用迴圈（例如 for、while、do-while）實現，它允許在特定條件成立的情況下重複執行一段程式碼，直到條件不滿足為止。","x":-175,"y":-1800,"width":920,"height":200,"color":"4"},
		{"id":"adf16a18878fd279","type":"text","text":"強封裝（Strong Encapsulation）指的是將數據和相關操作（方法）封裝在類別或對象內部，並限制外部直接訪問或修改數據的能力。這意味著只能通過類別或對象提供的方法來訪問和修改數據，而不是允許外部直接訪問類別的內部數據。\n\n在一些語言（如Java和C#）中，確實無法將類別的宣告和定義分離。這表示在這些語言中，類別的定義必須和宣告一起。這種設計可以看作是為了更清晰地管理程式碼，同時強調了類別的結構和內容的一致性。\n\n雖然這些語言無法像C++那樣明確地分離宣告和定義，但它們仍然強調了封裝的概念。透過訪問修飾符（如private、public、protected等），它們允許在類別內部限制對成員的訪問，從而達到封裝的效果，即防止外部直接訪問或修改類別的內部狀態。\n","x":320,"y":-840,"width":687,"height":320,"color":"4"},
		{"id":"7ffd5a404c6aefa4","x":320,"y":-480,"width":595,"height":196,"color":"4","type":"text","text":"。在這個例子中，結構 `NamedPoint` 可以被視為 `Point` 的擴展，同時在 C 語言中，這種擴展是通過結構中的成員順序來達到的。這裡 `NamedPoint` 結構保留了 `Point` 的前兩個成員，並增加了一個 `name` 成員。\n\n這種做法的確有些相似於繼承，因為 `NamedPoint` 結構在某種程度上擁有了 `Point` 結構的特性，即它包含了 `Point` 的部分成員"},
		{"id":"1b22346683bed52b","type":"text","text":"面向對象（OO）程式設計在控制移轉（control transfer）方面加入了一定程度的規範和結構化。面向對象的特性，如封裝、繼承、多型等，允許程式碼以一種更結構化和規範化的方式進行控制移轉。\n\n例如，面向對象的封裝特性允許將內部實現隱藏起來，只暴露必要的接口，從而控制對象之間的交互。繼承和多型的特性可以用於建立統一的介面和規範，這樣可以更容易地控制和管理程式碼的流程和行為。這樣的結構化控制移轉有助於減少程式碼中的耦合和混亂，使得程式設計更有組織性和可維護性。","x":300,"y":272,"width":784,"height":188,"color":"2"},
		{"id":"55ae285877b82194","x":320,"y":-223,"width":478,"height":163,"color":"4","type":"text","text":"倒轉了依賴關係，單純是在闡述高階不該直接依賴低階，應該對介面/抽象去寫程式而不是對具體寫程式，而且這麼做高階可以解耦，已經不在限定必須是該類別，而對於該類別來說，我反而仰賴高階需求（宮女不受寵）"},
		{"id":"9ecb94f5b4e2f115","type":"text","text":"什麼是ＯＯ，對於軟體架構師來說，ＯＯ是透過多型，來獲得對於系統中每個程式碼依賴方向的絕對控制力\n\n透過plugin架構，低層級的細節被包裝在 模組中，這些模組可以獨立於包含高層級策略的模組來進行部署","x":320,"y":0,"width":478,"height":160,"color":"4"},
		{"id":"861193eebd686426","x":735,"y":680,"width":349,"height":113,"color":"4","type":"text","text":"實務上，不太可能設計完全不可變元件，只是應該盡可能的把更多的處理放在不可變元件中"},
		{"id":"830addd9b1c04832","x":735,"y":900,"width":667,"height":700,"color":"4","type":"text","text":"1. **事件來源概念：**\n    \n    - 事件來源是一種策略，其核心思想是儲存交易（事件）而非特定時間點的狀態。\n    - 該策略允許當需要獲取狀態時，通過應用所有交易來計算狀態。\n    - 不同於傳統方式直接儲存狀態的方式，事件來源通過儲存事件或交易，來定義應用程式的狀態和行為。\n\n\n2. **應用程式的不可變性和功能性：**\n    \n    - 在事件來源的概念下，應用程式可以被設計為不可變的。這意味著資料儲存空間中的事件不會被刪除或更新，只會進行新增。\n    - 由於這種不可變性，應用程式變得更加穩定，並且沒有更新或刪除帶來的平行化問題。\n    - 若擁有足夠的儲存空間和處理器能力，就可以實現完全的不可變性，使得應用程式可以完全符合函數式編程的原則。\n\n3. **思考觀點：**\n    \n    - 這種方式可能會讓人感到荒唐，但實際上這就是許多原始碼控制系統的工作方式。透過事件來源的方式，記錄所有的事件並且按需計算狀態，應用程式變得更加靈活且容易維護。\n\n總的來說，事件來源提供了一種不同的概念來管理應用程式的狀態和資料。通過儲存事件並且按需計算狀態，可以實現更穩定且不可變的應用程式設計，這與傳統的直接儲存狀態的方式有所不同。\n\n\n## 事件來源（Event Sourcing）通常不被歸類為函數式編程的範疇，而是更與事件驅動架構（Event-Driven Architecture）相關聯。\n"},
		{"id":"401e5aaa0933ad2a","x":-1020,"y":1400,"width":336,"height":160,"color":"4","type":"text","text":"\"間接\"可以指的是使用抽象概念，如繼承、多型等，來間接地對對象進行操作。例如，通過繼承，子類可以間接地訪問和重用父類的屬性和方法，從而實現代碼的重用性和擴展性。"},
		{"id":"79fe9ee2ad4459cf","type":"text","text":"## 開放-封閉原則（Open-Close Principle，OCP）\n\n\"**_Software entities (class, modules, functions, etc.) should be open for extension, but closed for modification._**\"\n**一個軟體個體應該要夠開放使得它可以被擴充，但是也要夠封閉以避免不必要的修改**\n\n\"**When a single change to a program results in a cascade of changes to dependent modules, the design smells of Rigidity. The OCP advises us to refactor the system so that further changes of that kind will not cause more modifications. If the OCP is applied well, then further changes of that kind are achieved by adding new code, not by changing old code that already works.**\"\n\n當一個程式的單一修改導致相依模組需要連帶==大量修改==時，這種情況可能代表著設計上的==僵化==（Rigidity）。開放封閉原則（Open/Closed Principle，OCP）建議我們重構系統，使得未來類似的修改不再需要更多修改。如果 OCP 被有效運用，那麼進一步的類似修改應該透過新增新的程式碼來實現，而不是改變已經運作正常的舊程式碼。\n\n當程式碼遵循開放封閉原則，即設計能夠容易擴展而不需修改現有程式碼時，系統更能應對變化，新的功能或需求可以透過新增程式碼來實現，而不會引發對現有正常運作的程式碼的修改。这樣的設計有助於降低系統的脆弱性，提高可擴展性和維護性。\n\n----\n\n既然程式已經寫好了，為什麼還要去改它呢？ 兩個主要的原因：  \n  \n- 要增加功能。\n- 要修正問題（bugs）。\n\n  \n那為什麼改程式那麼可怕？因為要修改一個已經可以動的系統的某個模組，很容易造成 \n==\"a single change to a program results in a cascade of changes to dependent modules\"== \n也就是因為模組之間會有 coupling（耦合），因此產生==牽一髮而動全身==的效應。 \n如果有足夠的**自動化測試案例**來驗證**此次修改沒有破壞原本可以正常動作的功能**，那麼相對來講這種**漣波效應（ripple effect）** 其實也就沒有那麼可怕。但是實務上 **自動化測試永遠都不夠多**，所以如果能從 ==設計面== 著手從而避免掉這種牽一髮而動全身的漣波效應，則軟體系統將會變得很容易修改，擴充，了解，與維護。\n\n\n----\n# GRASP原则\n\n\n**識別可能變化的點：** 首先，需要識別在系統中可能發生變化的地方或元件。這些變化可能來自需求的變更、外部條件的改變或其他因素。\n\n**創建穩定的介面：** 一旦確定了這些可能變化的點，就需要建立一個穩定的介面或抽象來圍繞這些點。這個穩定的介面可以是一個接口、抽象類別或設計模式，目的是隔離變化，使得系統其他部分不受變化的影響。\n\n==受保護的變異模式== 鼓勵在系統設計中考慮可能發生變化的地方，然後通過創建穩定的介面來隔離這些變化，以保護系統其他部分免受影響。这样的設計有助於使系統更靈活、可擴展和易於維護。","x":-520,"y":2200,"width":740,"height":1400,"color":"2"},
		{"id":"1c010c9c3af4c5c6","type":"text","text":"## 介面隔離原則（Interface Segregation Principle，ISP）         \n**\"No client should be forced to depend on methods it does not use.\"**\n**\"不應該去依賴你根本不會用到的東西\"**\n\n最小化類別與類別之間的介面\n介面過肥胖會讓使用的人有不正常的耦合關係，這種關係會使需要經常變更需求的敏捷開發會容易產生Bug，所以要盡量依照用戶功能來縮小或客制\n\n \n 違反單一責任原則SRP?\n\n在分割的過程中當然不能違反SRP，只不過SRP是以開發角度去設計的，注重的是職責，然而ISP是以用戶端角度去分割的，注重的是對介面的依賴隔離，就我認為當模組遵守SRP後依照用戶需求再去分離客製與抽象介面，進而設計框架\n","x":1040,"y":2200,"width":780,"height":360,"color":"2"},
		{"id":"a7184b48f7f31a42","type":"text","text":"## 依賴反向原則（Dependency Inversion Principle，DIP）\n **\"High-level modules should not depend on low-level modules. Both should de\n pend on abstractions.\"**\n**高層模組不應該依賴於低層模組。兩者皆應該依賴抽象。**\n\n**\"Abstractions should not depend on details. Details should depend on abstractions.\"**\n**抽象不應該依賴細節。細節應該依賴抽象**\n\n\n倒轉了依賴關係，單純是在闡述高階不該直接依賴低階，應該對介面/抽象去寫程式而不是對具體寫程式，而且這麼做高階可以解耦，已經不在限定必須是該類別，而對於該類別來說，我反而仰賴高階需求\n\n\n範例: 當「撰寫產品程式」對「工程師」直接依賴的時候，老闆請 \"小明\" 寫程式，此時老闆依賴於 \"小明\"，今天小明離職了，老闆就GG了，因為老闆依賴 \"小明\"。\n如果情境改成，老闆請\"工程師\"寫程式，此時老闆依賴的只是一位\"工程師\"，並且明確限定了 \"工程師\" 就是負責 \"寫程式\"。 此時，對於老闆來說 \"工程師\" 是誰就不重要了，因為都一定會寫程式，換句話說，只要是 \"工程師\" 都能來工作，變得 \"小黑\", \"小黃\" 都可以來應徵，變得是 \"小黃\", \"小黑\" 依賴於 老闆給它一份工作。\n\n","x":1860,"y":2200,"width":720,"height":500,"color":"2"},
		{"id":"07c3f7c27a681b03","type":"text","text":"# **名詞解釋**\n\n- _高階與低階，是相對關係，其實也就是 呼叫者 (Caller) 與 被呼叫者 (Callee)_\n- _People 為高階，Hamburger、Spaghetti… 為低階模組。抽象，是指 介面 (interface) 或是 抽象類別 (Abstract Class)， 也就是不知道實作方式，無法直接被實例化。具體實作方式，就是指有實作介面或是繼承抽象的 非 抽象類別。_","x":2700,"y":2280,"width":680,"height":200,"color":"4"},
		{"id":"e5bf56cd0b5047ae","type":"text","text":"## 里氏替換原則（Liskov Substitution Principle，LSP)\n\n**\"If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program (correctness, task performed, etc.)._\"**\n**子類別必須能夠替換父類別 ， 子類別替換父類別後，不需要改變，也不會發生任何錯誤或異常**\n\n**我們預期了這個函式或類別需要準備的輸入參數，也預期了應該要有的輸出結果。如果某一天替換了子類別，卻不是這麼一回事，就會發生很多意料外的錯誤**\n\n- **先驗條件不可以強化**：父類別要求的是矩形，子類別就不能要求得更嚴，只准人家給正方形\n- **後驗條件不可以弱化**：父類別產出的是正方形，子類別不能說沒關係啦，就給人家隨便一個矩形\n- **不變條件必須保持不變**：父類別是一個產生矩形的方法，子類別不能背骨，跑去產生圓形\n\n若只是想要共用父類別的邏輯，應該使用組合，而不是使用繼承。雖然沒有人會限制開發人員隨意地使用繼承，但如果使用繼承的目的不是為了「多型」，不但沒有讓繼承功能派上用場，還會迫使子類別公開父類別的「介面」\n\n\n規則一: Covariance of argument\n當你實作或是繼承一個superClass的方法時 你方法的input argument的數目應該一樣\n\n規則二: Covariance of result\n當你實作或是繼承一個superClass的方法時 你方法的回傳的數目應該一樣\n\n規則三: Exception rule\n當你實作或是繼承一個superClass的方法時 拋出的例外 必須是superClass方法拋出的例外的subType\n\n規則四: subType的函式需要的precondition 不能比baseType的還要嚴謹(strict)\n\n規則五: subType的函式需要的postcondition 不能比baseType的還要鬆散(weak)\n\n規則六: 一個subtype的類別的invariant 必須包含所有baseType的invariant\n\n規則七: 一個subtype的類別的constraint 必須包含所有baseType的constraint\n\n\n多用組合少用繼承 除非是有多態\n如果單純要減少重複程式碼 可以使用其他手段 like wrapper, trait ","x":260,"y":2200,"width":740,"height":940,"color":"2"},
		{"id":"95348d7cfd078de1","type":"text","text":"## 設計原則\n\n以蓋房子來說，如果磚塊很爛，那建築物的架構也就不重要了。另一方面，你也能使用精緻的磚塊來製造大量的垃圾\n\n對於以上，就是 SOLID 原則想改善的問題\n\nSOLID 原則告訴我們該如何將函式和資料結構安排到類別中，以及類別間該如何相互關聯\n\n- 單一職責原則（Single Responsibility Principle，SRP）：每個模組只對唯一一個角色負責\n- 開放-封閉原則（Open-Close Principle，OCP）：要使軟體系統容易更改，必須設計成允許透過新增程式碼的方式來變更系統的行為。例如：引入 module\n- 里氏替換原則（Liskov Substitution Principle，LSP）：子類別要能完全取代父類別，讓程式碼能更穩固強健（robust）\n- 介面隔離原則（Interface Segregation Principle，ISP）：避免依賴用不到的東西，讓程式碼能更有彈性，便於實作多型\n- 依賴反向原則（Dependency Inversion Principle，DIP）：避免因底層模組修改細節而需更動高階抽象模組；凡事應依賴抽象介面，避免耦合度過高。","x":-580,"y":1760,"width":1220,"height":340},
		{"id":"7d507adccdf9d5fe","type":"text","text":"## 單一職責原則（Single Responsibility Principle，SRP）\n\n“**_A class should have only one reason to change.”_**\n**一個模組應有且只有一個理由會使其改變 (唯一一個使用者或利益相關者負責)。**\n\n可是如果現在有多個使用者或利益相關者希望以相同的方式改變的話，我們不就會輕易地違反定義了嗎？\n\n所以我們需要為一群希望以相同的方式改變的使用者或利益相關者一個定義，在這邊作者稱之為==角色==。\n\n最終定義為：==一個模組應只對唯一的一個角色負責==\n\n\n\n\n假設有一個名為 `Order` 的類別，它負責處理訂單的相關邏輯。按照 SRP 的原則，`Order` 類別應該只負責處理訂單相關的工作，如建立訂單、計算訂單總額、處理支付等。\n\n現在，想像一下如果 `Order` 類別負責太多的事情，比如同時處理庫存管理、訂單運送和報告生成等功能。這樣的類別可能變得非常龐大複雜，不僅難以維護和理解，而且當其中一個功能需要修改時，可能影響到其他功能，增加了代碼的脆弱性。\n\n這時候，遵循 SRP 的原則，我們可以將不同的責任分離到不同的類別中。比如，庫存管理可以有一個獨立的 `InventoryManager` 類別，訂單運送可以有一個 `ShippingService` 類別，報告生成可以有一個 `ReportGenerator` 類別。這樣每個類別都專注於單一的責任，提高了程式碼的清晰度和可維護性。\n\n透過 SRP 的遵循，==程式碼變得更易於理解和擴展，當需求變化時，只需修改單一職責的類別，而不必擔心影響到其他不相關的功能==。這種結構可以使得代碼更模組化、更容易測試和維護，同時也更符合良好的設計原則。","x":-1340,"y":2200,"width":780,"height":680,"color":"2"}
	],
	"edges":[
		{"id":"d3b123ec63cf463f","fromNode":"3b8b7529cc723ab4","fromSide":"right","toNode":"1b22346683bed52b","toSide":"left"},
		{"id":"4f525c0e4f412ab8","fromNode":"95348d7cfd078de1","fromSide":"bottom","toNode":"79fe9ee2ad4459cf","toSide":"top"},
		{"id":"1bd35b87677ba536","fromNode":"95348d7cfd078de1","fromSide":"bottom","toNode":"7d507adccdf9d5fe","toSide":"top"},
		{"id":"f7df6a02b1c56a5b","fromNode":"95348d7cfd078de1","fromSide":"bottom","toNode":"e5bf56cd0b5047ae","toSide":"top"},
		{"id":"b0556c1d6d6c2744","fromNode":"95348d7cfd078de1","fromSide":"bottom","toNode":"1c010c9c3af4c5c6","toSide":"top"},
		{"id":"b10218f7a95da669","fromNode":"95348d7cfd078de1","fromSide":"bottom","toNode":"a7184b48f7f31a42","toSide":"top"},
		{"id":"eae3cbffe22bca36","fromNode":"07c3f7c27a681b03","fromSide":"left","toNode":"a7184b48f7f31a42","toSide":"right"},
		{"id":"e6c014661bab6479","fromNode":"cc8605240e2c734a","fromSide":"left","toNode":"531018b62c8b2b62","toSide":"right"},
		{"id":"35754e338b598429","fromNode":"a59066e4d46b8268","fromSide":"left","toNode":"531018b62c8b2b62","toSide":"right"},
		{"id":"c98da21a4223da57","fromNode":"7afc2066799129de","fromSide":"right","toNode":"bd1646d32d33209f","toSide":"left"},
		{"id":"1e78113d071f52cc","fromNode":"b8c5ca81fcdfea54","fromSide":"right","toNode":"bd1646d32d33209f","toSide":"left"},
		{"id":"39ae65082bb1655c","fromNode":"c6d3ea1b04c2e831","fromSide":"right","toNode":"bd1646d32d33209f","toSide":"left"},
		{"id":"4d231fdd928d643d","fromNode":"94faa61e87a84cea","fromSide":"bottom","toNode":"07127ef8f304e0e7","toSide":"top"},
		{"id":"7e64b87684af94bf","fromNode":"adf16a18878fd279","fromSide":"left","toNode":"3b8b7529cc723ab4","toSide":"right"},
		{"id":"68127f88970d5c19","fromNode":"7ffd5a404c6aefa4","fromSide":"left","toNode":"3b8b7529cc723ab4","toSide":"right"},
		{"id":"9674ca279f44d29e","fromNode":"55ae285877b82194","fromSide":"left","toNode":"3b8b7529cc723ab4","toSide":"right"},
		{"id":"5b86515b72b967fb","fromNode":"9ecb94f5b4e2f115","fromSide":"left","toNode":"3b8b7529cc723ab4","toSide":"right"},
		{"id":"fc13b5ae0c46f495","fromNode":"b177a35d5826d0a1","fromSide":"right","toNode":"861193eebd686426","toSide":"left"},
		{"id":"00fed87e3b67cf0f","fromNode":"b177a35d5826d0a1","fromSide":"right","toNode":"830addd9b1c04832","toSide":"left"},
		{"id":"d3ea568fddbc67e5","fromNode":"401e5aaa0933ad2a","fromSide":"right","toNode":"b177a35d5826d0a1","toSide":"left"}
	]
}